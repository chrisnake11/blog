---
title: 策略模式
published: 2025-09-05T09:10:36Z
description: '设计模式之策略模式和适配器模式，使用手机充电器和设备充电的例子来说明。'
image: ''
tags: [策略模式, 适配器模式]
category: '设计模式'
draft: false
---

# 策略模式

所谓策略模式（Strategy Pattern），是一种行为设计模式，旨在将算法接口和数据分开封装，使它们可以任意的组合，并交给上层接口调用。

## 适用场景

+ 需要根据不同的数据对象，执行不同的算法时，可以将这些操作和数据对象各自抽象为2个接口，再分别实现它们的具体类。

保证每个类都只对应一种功能，符合**单一职责原则**。

就好比插座上可以用给不同手机充电器充电，但是不同的手机需要不同的充电器。

所以我们可以将充电器和手机分别抽象为2个接口，然后实现它们的具体类。

甚至可以将充电器和手机的任意组合交给上层函数进行调用。

## 示例

```cpp
class DeviceCharger{
public:
    virtual void charge(Device* device) = 0;
}
// 定义充电接口类
class TypeCDeviceCharger : public DeviceCharger{
public:
    virtual void charge(Device* device) = 0;
};

class HuaweiCharger: public TypeCDeviceCharger{
public:
    void charge(Device* device) override {
        // 充电逻辑
    }
};

class XiaomiCharger: public TypeCDeviceCharger{
public:
    void charge(Device* device) override {
        // 充电逻辑
    }
};

// 定义电器接口类
class Device{};

class Phone: public Device{};

class PC : public Device{};

class Huawei: public Phone{};

class Xiaomi: public Phone{};


// 充电函数，接受充电器和手机对象，对不同的手机，使用不同的充电器进行充电

// 根据具体传入的参数，手机和充电器可以任意组合
void charge(Device* device, DeviceCharger* charger){
    // 充电
    charger->charge(device);
}


int main(){
    Phone* huawei = new Huawei();
    Phone* xiaomi = new Xiaomi();

    TypeCDeviceCharger* huaweiCharger = new HuaweiCharger();
    TypeCDeviceCharger* xiaomiCharger = new XiaomiCharger();

    // 给华为手机充电
    charge(huawei, huaweiCharger);

    // 给小米手机充电
    charge(xiaomi, xiaomiCharger);

    // 给华为手机使用小米充电器充电
    charge(huawei, xiaomiCharger);

    // 给小米手机使用华为充电器充电
    charge(xiaomi, huaweiCharger);

    return 0;
}
```

### 策略模式和模板特化

在策略模式中，如果存在有限个数据类型，每个数据类型需要对应的算法接口。为了实现编译器的类型检查，我们可以使用模板特化对同一个算法逻辑，实现多个数据类型的算法接口类。

例如：对于加法的接口类，可以针对不同的数据类型 `(int, string, point)`，实现编译器类型检查，以及不同的加法逻辑。

# 适配器模式

适配器模式（Adapter Pattern）是一种结构设计模式，旨在将一个接口封装转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

例如：假设上面的华为充电头可以支持100W输出，我想要用它给PC充电，就可以另外写一个适配器类，将充电头接口适配PC的100wPD快充协议。

```cpp
class HuaweiChargerAdapter : public TypeCDeviceCharger{
public:
    HuaweiCharger* charger;
    void charge(Device* device) {
        // 调整电压电流适配PC充电逻辑
        // 再调用华为充电器的充电方法
        charger->charge(device);
    }
};

int main(){
    PC* pc = new PC();

    HuaweiCharger* huaweiCharger = new HuaweiCharger();
    TypeCDeviceCharger* pcCharger = new HuaweiChargerAdapter(huaweiCharger);

    // 让华为充电器适配给PC充电
    charge(pc, pcCharger);

    return 0;
}
```

# 参考资料

[让虚函数再次伟大！](https://github.com/parallel101/course/blob/master/slides/design/virtual.md)

[bilibili: 速通面向对象设计模式（1）：策略、工厂、迭代器、适配器、享元、代理](https://www.bilibili.com/video/BV1u1421i7GV?spm_id_from=333.788.videopod.sections&vd_source=caf7bc500eb03a267461b0af17a20763)
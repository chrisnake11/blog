---
title: 工厂模式
published: 2025-09-05T09:55:39Z
description: '设计模式之工厂模式，使用游戏中的枪械和子弹的例子来说明。'
image: ''
tags: [工厂模式, 享元模式]
category: '设计模式'
draft: false
---

# 工厂模式

工厂模式（Factory Pattern）是一种创建型设计模式，旨在将对象的创建逻辑与使用逻辑分离，在调用接口的同时根据传递的参数动态创建对象。

## 适用场景

例如：在游戏中我们的枪械需要不同的子弹类型。我们可以为每种子弹类型创建一个工厂类，根据传入的参数动态创建不同的子弹对象。

通过设计工厂模式，我们可以将Gun作为Bullet的工厂类，负责创建不同类型的子弹对象。player只需要调用Gun工厂的shoot方法就可以发射子弹，而不需要关心具体的子弹类型。

## 示例

```cpp
class Bullet{
public:
    virtual bool isExplosive() const {
        return false;
    }
    virtual void explode() = 0;
};

class ExplosiveBullet: public Bullet{
public:
    bool isExplosive() const override {
        return true;
    }

    virtual void explode() = 0;
};

class AK47Bullet: public Bullet{};

class M4A1Bullet: public Bullet{};

class GernadeBullet: public ExplosiveBullet{
public:
    void explode() override {
        // 手雷爆炸逻辑
    }
};

class Gun{
public:
    virtual Bullet* shoot() = 0;
};

class AK47: public Gun{
public:
    Bullet* shoot() override {
        // 具体的子弹创建逻辑
        return new AK47Bullet();
    }
};

class M4A1: public Gun{
public:
    Bullet* shoot() override {
        // 具体的子弹创建逻辑
        return new M4A1Bullet();
    }
};

class Gernade: public Gun{
public:
    Bullet* shoot() override {
        // 具体的子弹创建逻辑
        return new GernadeBullet();
    }
};

void playerShoot(Gun* gun) {
    Bullet* bullet = gun->shoot();
    if (bullet->isExplosive()) {
        bullet->explode();
    }
    // 记得释放子弹内存
    delete bullet;
}

int main() {
    Gun* gun1 = new AK47();
    playerShoot(gun1);

    Gun* gun2 = new M4A1();
    playerShoot(gun2);

    Gun* gun3 = new Gernade();
    playerShoot(gun3);

    return 0;
}
```

## 模板元编程结合工厂模式

```cpp
template <class B>
struct GunWithBullet : Gun {
    static_assert(is_base_of<Bullet, B>::value, "B 必须是 Bullet 的子类");

    Bullet *shoot() override {
        return new B();
    }
};

void playerShoot(Gun *gun) {
    Bullet *bullet = gun->shoot();
    if (bullet->isExplosive()) {
        bullet->explode();
    }
}

int main() {
    Gun *gun1 = new GunWithBullet<AK47Bullet>();
    playerShoot(gun1);

    Gun *gun2 = new GunWithBullet<M4A1Bullet>();
    playerShoot(gun2);

    Gun *gun3 = new GunWithBullet<GernadeBullet>();
    playerShoot(gun3);

    return 0;
}
```

## 超级工厂模式

根据类型的名称，动态的调用不同的工厂类生产对象。

```cpp
Gun* createGun(const std::string& gunType) {
    if (gunType == "AK47") {
        return new GunWithBullet<AK47Bullet>();
    } else if (gunType == "M4A1") {
        return new GunWithBullet<M4A1Bullet>();
    } else if (gunType == "Gernade") {
        return new GunWithBullet<GernadeBullet>();
    } else {
        throw runtime_error("未知的枪械类型"); // 抛出异常
    }
}

int main() {
    std::unique_ptr<Gun> gun1 = createGun("AK47");
    playerShoot(gun1.get());

    std::unique_ptr<Gun> gun2 = createGun("M4A1");
    playerShoot(gun2.get());

    std::unique_ptr<Gun> gun3 = createGun("Gernade");
    playerShoot(gun3.get());

    return 0;
}

```

+ 使用智能指针，避免内存泄漏。

```cpp
int main() {
    std::unique_ptr<Gun> gun1 = createGun("AK47");
    playerShoot(gun1.get());

    std::unique_ptr<Gun> gun2 = createGun("M4A1");
    playerShoot(gun2.get());

    std::unique_ptr<Gun> gun3 = createGun("Gernade");
    playerShoot(gun3.get());

    return 0;
}
```

# 参考资料

[让虚函数再次伟大！](https://github.com/parallel101/course/blob/master/slides/design/virtual.md)

[bilibili: 速通面向对象设计模式（1）：策略、工厂、迭代器、适配器、享元、代理](https://www.bilibili.com/video/BV1u1421i7GV?spm_id_from=333.788.videopod.sections&vd_source=caf7bc500eb03a267461b0af17a20763)
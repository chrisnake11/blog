---
title: 08类注意事项
published: 2025-08-31T21:32:29Z
description: '介绍'
tags: ['C++']
category: 'C++'
---


# 面向对象编程

## 多态

要想使用多态需要满足以下2点：
1. 基类中成员函数为虚函数`virtual`。
2. 变量类型必须为基类指针或者引用，实例类型为派生类。
3. 函数参数类型必须是基类类型的引用或指针。

```cpp
#include <iostream>

class Base {
public:
    void print() const{
        std::cout << "base" << std::endl;
    }
    void selfPrint()
};

class Derived : public Base {
public:
    void print() const{
        std::cout << "derived" << std::endl;
    }
    // 非virtual，不能override
    // void print() const override{
    //     std::cout << "derived" << std::endl;
    // }
    void selfPrint() const{
        std::cout << "derived self print" << std::endl;
    }
};

void foo(Base  &const s) {
    s.print();
}

int main() {
    Base b;
    foo(b);
    Derived d;
    foo(d); // 调用base
}
```

多态的正确打开方式：

```cpp
#include <iostream>

class Base {
public:
    // virtual关键字，将会被重写
    virtual void print() const{
        std::cout << "base" << std::endl;
    }
    virtual void selfPrint() const{
        std::cout << "base self print" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() const{
        std::cout << "derived" << std::endl;
    }
    void selfPrint() const{
        std::cout << "derived self print" << std::endl;
    }
};

void foo(Base  &const s) {
    s.print();
}

// 报错
void bar(Base * const s) {
    s->selfPrint(); // base基类没有selfPrint
}

int main() {
    Base b;
    foo(b); // 调用base
    // 函数参数的多态
    Derived d;
    foo(d); // 调用derived

    // 变量的多态
    Base* bp = new Derived();
    bp->print(); // 调用derived;
    bar(bp); // 调用Derived
    std::unique_ptr<Base> bup = std::make_unique<Derived>();
    bup->print(); // 调用derived
}
```

## 派生类都继承的成员变量，不要设置为protected直接访问。

当派生类需要定义同一种成员变量时，不要再基类中直接设置为protected，而是定义为private，并且使用protected的getter和setter函数让派生类进行访问。

```cpp
class Animal{
public:
    Animal(): _age(0){}
protecte:
    int _age; // 让派生类直接访问 (x)
};
class Dog : public Animal{
public:
    void printAge(){
        std::cout << Animal::_age << std::endl;
    }
};
```

```cpp
class Animal{
public:
    Animal(): _age(0){}
protected:
    // 使用protected函数，实现访问控制
    int getAge() const { return _age; }
private:
    int _age;
};
class Dog : public Animal{
public:
    void printAge(){
        std::cout << getAge() << std::endl;
    }
};
```

## 不要使用继承和派生来避免数据冗余。

当部分派生类需要额外的数据，而部分不需要时，应当每种派生类各自定义自己的成员变量，而不是在基类中定义冗余的成员变量。

## OOP的准则

1. 使用is-a的关系来设计类的继承结构。
2. 使用has-a的关系来设计类的组合结构。
3. 不要消除成员数据上的冗余，使用组合来复用代码。
4. 避免过深的继承层次。
5. 数据成员应当始终是private的，包括派生类共享的基类数据。

+ virtual member function
1. 作为可以被继承的，并且对外暴露的接口。
2. virtual member function尽量为纯虚函数。
3. 使用non-virtual的public函数调用virtual member function。
4. 基类的虚构函数应当声明为virtual，并且在派生类中重写，或者protected + non-virtual。

## OOP的优劣

### 性能表现

1. 虚函数使得内联失效，这会带来性能损失。没有内联，函数调用需要额外的开销，对于高频调用的函数，性能影响更为明显。
2. 在很多场景下多态的编写并不简单，并且往往未真正地利用多态。
3. 大量使用继承和多态使得代码层次关系过于复杂，难以维护。

### C++是一个多范式的语言（而不是简单的OOP）

1. OOP只是众多编程范式中的一种，C++同时支持函数式编程、泛型编程等多种范式。
2. 函数式和泛型编程能够做得更好。
3. 不要局限于只使用OOP编程。

# 其他
## 成员变量默认用_开头

## 不修改，尽量使用const引用类型

在构造函数、成员函数、运算符重载中，如果不会修改传递的参数，应当把形参定义为const引用类型。

## 拷贝构造函数

在拷贝构造中，应当使用const引用类型.

> 如果不使用引用，在传递参数时会重复出发拷贝构造。

## 构造函数中，引用类型成员必须放在初始化列表中构造

## 静态类型成员变量或者函数，需要单独定义

## 移动构造的意义

1. 减少拷贝。
2. 当类内成员，存在无法拷贝（没有拷贝构造函数）的对象时，只能使用移动构造函数。

## static函数只能访问static变量

## 拷贝赋值运算符

注意：如果是自拷贝，直接返回。

```cpp
Student& Student::operator=(const Student & student){
    if(this != student){
        this->name = student._name;
        *(_data) = *(student._data); // 深拷贝
        ...
    }
    return *this;
}
```

## 移动赋值运算符

```cpp
Student& Student::operator=(Student && student) noexcept{
    if(this != student){
        this->name = std::move(student._name);

        _data = new int();
        (*_data) = std::move((*student._data)); // 移动(类似深拷贝)
        ...
        // 或者直接浅拷贝，要特别处理析构函数
        _data = student._data;
        student._data = nullptr; // student析构函数需要处理nullptr情况。
    }
    return *this;
}
```

## 重载流输入输出运算符

流式输入输出运算符，需要两个参数，分别作用于`std::ostream`类型和输入的数据上。

并且流式输入输出运算符，可以被递归调用，因此返回的仍然是`std::ostream`类

流式输入输出运算符，不属于类的成员函数，因此需要声明为友元。

```cpp
class Student{
    ...
    // 声明为友元
    friend std::ostream& operator<<(std::ostream& os, Student& student);
};


// 在.cpp中实现
std::ostream& operator<<(std::ostream& os, Student& student){
        os << "student'name is " << student._name << std::endl;
        return os
    }
```

## 默认拷贝构造与拷贝赋值

系统会默认生成一个拷贝赋值运算符。该运算符按照成员声明的顺序，逐个拷贝每个成员变量。

1. 逐个拷贝：默认拷贝构造函数会逐个拷贝所有的非静态成员变量。
2. 指针成员：如果类中有指针成员，默认拷贝构造函数只会拷贝指针的值（地址），而不会拷贝指针所指向的对象。这可能会导致多个对象指向同一块内存，进而引发问题（如双重释放、内存泄漏等）。
3. `const` 和`引用成员`：如果类中有`const`成员或引用成员，编译器不会生成默认的拷贝构造函数，因为这些成员不能被复制。
4. 类中包含不可拷贝对象时，无法合成默认拷贝构造函数

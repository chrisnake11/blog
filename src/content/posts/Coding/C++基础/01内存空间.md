---
title: C++内存空间
published: 2025-08-31T15:10:14Z
description: 'C++内存空间'
image: ''
tags: ['C++']
category: 'C++'
---

# 操作系统下的内存空间

**以下代码都在Debug模式下编译运行，确保不会被编译器优化。**

+ 代码区：存储机器指令。共享且只读
+ 全局/静态存储区：存储全局变量和类的静态变量。这些变量在整个程序运行期间都会存在，但是它们的可见性和生命周期取决于作用域。
+ 常量区`.rodata`：存储常量数据，**字面值数据**，只读无法修改。
+ 栈：存储函数的局部变量、参数、返回地址等数据。
+ 堆：存储程序员手动分配的数据，如new、malloc等。

下面用代码来举例：

```cpp
#include <iostream>
#include <vector>

int global_var = 1;  // 全局区

int* const cp1 = &global_var; // 常量区(全局常量数据)
const int ci = 3; // 常量区

class Animal {
public:
    static int weight; // 静态区
    static const int age; // 常量区(静态常量数据)
};

int Animal::weight = 0; // 静态区
const int Animal::age = 0; // 常量区

int main() { // 栈区
    int* const cp2 = &global_var; // 栈区(常量指针)
    int animal_num = 5; // 栈区
    std::vector<Animal> animals(animal_num); //栈区 + 堆区
}
```

> 常量数据:
> 
> + 全局常量数据通常存储在`.rodata`中，而不是全局区中。
> + 类内的静态常量数据存储在`.rodata`中，
> + 局部常量数据，编译器不会存储在`.rodata`中，而是直接存储在栈中。
>
> `animals`分为`vector元数据`和`data`两个部分，分别存储在栈和堆中。

## 内存对齐

代码：
```cpp
#include <iostream>
#include <string>

struct A{
    int a;
    double b;
    int c;
}

int main(){
    A a;
    a.a = 123;
    a.b = 456.78;
    a.c = 910;

    std::cout << "a address: " << &a.a << std::endl;
    std::cout << "b address: " << &a.b << std::endl;
    std::cout << "c address: " << &a.c << std::endl;
}
```

输出如下：
```
a address: 00000031846FFAF8
b address: 00000031846FFB00
c address: 00000031846FFB08
```

**为什么b与a的内存相差为8字节，不是4字节的int数据？**

**知识点**：堆栈内存的分布，除了受到分配的相对顺序和变量大小的影响，还受到**内存对齐规则**的影响。

首先，栈中的内存按照`a, b, c`的顺序分配内存空间。

为了提高内存访问效率，编译器通常会遵循内存对齐规则，不同了类型的数据对齐的边界大小不同。
+ `int`类型通常为`4`字节
+ 64位系统中，指针类型为`8`字节

`a`的起始地址为`xx84`，分配32字节后的内存地址为`xxA4`,显然不是8的倍数。

`b`为双精度浮点数类型，按照内存对齐规则需要从`8`的倍数开始，因此需要空出`4`字节内存空间，从`xxA8`开始分配`b`的内存。

`c`为整型，按照内存对齐规则需要从`4`的倍数开始，因此需要空出`4`字节内存空间，从`xxB0`开始分配`c`的内存。

因此：a与b的地址相差`4 + 4 = 8`字节，包括`4`字节的int数据，和`4`字节的对齐空间。

**但是，如果把`b`和`c`的顺序调换，就能节省内存空间。**

```cpp
struct A{
    int a;
    int c;
    double b;
};
```
输出结果中可以看出，a和c被放在一个8字节的对齐空间中。因此a和c只相差4字节，而a与b相差8字节。
```
a address: 00000064E12FFC38
c address: 00000064E12FFC3C
b address: 00000064E12FFC40
```

# C++视角下的内存空间

在C++标准下，其实并没有规定具体的内存布局方式，这主要依赖于编译器的实现。

上一节介绍的内存布局确实是操作系统层面上的布局，并且编译器在实现时会考虑到这些因素，以优化内存的使用和访问效率。但这并不是程序员所看到的内存空间。

从C++程序所看到的内存布局是由编译器决定的，经过编译器的优化和调整，最终生成的机器代码可能与我们所想的在操作系统中的变量布局并不完全一致。

> C++标准并没有定义函数变量或者局部变量必须在栈上分配内存，也没有规定全局变量必须在静态存储区中分配内存。

**重点：虽然C++没有这样规定，但是编译器的代码实现往往要根据操作系统进行调整，因此编译器在往往是按照操作系统的内存结构来实现的（例如：虚表，堆区，栈区等...），但是又存在少数细节编译器会根据代码进行优化。**

## 存储期(storage duration)

[cpp reference](https://en.cppreference.com/w/cpp/language/storage_duration.html)

[c++ draft](https://eel.is/c++draft/basic.stc)

`storage duration`存储期是对象的一个属性，它定义了包含该对象的存储的最小潜在生命周期。存储期由用于创建对象的构造决定,定义了C++中对象的存储分配方式，包括以下几种：

1. **静态存储期`static storage duration`**：在程序整个运行期间都存在，通常用于全局变量和静态变量。
2. **动态存储期`dynamic storage duration`**：在程序运行时动态分配，通常用于通过`new`或`malloc`等方式分配的内存。
3. **自动存储期`automatic storage duration`**：在函数调用时分配，函数返回时自动释放，通常用于局部变量，通常直接分配在同一个栈帧中（不保证连续性）。
4. **线程存储期`thread storage duration`**：在多线程环境中，每个线程都有自己的存储空间，通常用于线程局部变量。

让我们重新审视一下这份代码：
```cpp
#include <iostream>

int main() {
    int a = 123;
    double b = 123.456;
    double* c = &b;
    std::cout << "a address: " << &a << std::endl;
    std::cout << "b address: " << &b << std::endl;
    std::cout << "c address: " << &c << std::endl;
    std::cout << "b value: " << b << std::endl;
    // 添加这行代码后，内存按顺序分配
    std::cout << "*(double*)((char*)a+8) value: " << *(double*)((char*)&a + 8) << std::endl;

    return 0;
}
```
内存的分配是无序的
```bash
a address: 0x7ffc33852d7c
b address: 0x7ffc33852d70
c address: 0x7ffc33852d68
```
添加访问&a的代码后，输出如下：
```bash
a address: 0000000CE4CFF740
b address: 0000000CE4CFF748
c address: 0000000CE4CFF750
b value: 123.456
*(double*)((char*)a+8) value: 123.456
```

从局部变量在栈上按顺序分配的角度来看，`&b == (char*)&a + 8`, `&c == (char*)a + 16`。但是从输出结果可以看出，`c`的地址最小，随后分配了`b`的地址，而不是`a`的地址。

> 添加*(double*)((char*)a + 8)后，编译器为了保证代码的正常执行，会自动优化内存顺序，使得程序成功运行。

因此，实际的内存空间与栈上分配的顺序并不完全一致，有可能随机顺序分配，因此**想要通过指针移位来访问其他变量的行为并不可靠**。
> 甚至在某些极端的优化条件下，编译器会把automatic storage类型的变量直接分配在寄存器上，压根没有分配内存空间，这样**在部分局部变量之间会存在未定义的内存空间**

但是，对于结构体、类、数组等标准库容器，编译器会按照一定的规则来分配内存，以确保它们的成员变量在内存中的布局是连续的。因此，在这些情况下，通过指针移位来访问其他成员变量的行为是可靠的。

## 指针的转换

在C++中，指针的转换只有`static_cast, dynamic_cast, const_cast, reinterpret_cast`四种，其他的C风格的写法，如(int*)，会被直接转译为`reinterpret_cast<int>`来使用。

在指针之间进行转换时，往往要考虑原始类型所占的空间大小，运行小的转为大的，而不能大的转小的(int to short)。

如果想要进行数据转换，例如`int to short`，建议使用`memcpy()`来实现。

## 内存指针的解引用

在解引用变量指针时，应当只使用与变量类型相同的指针类型进行解引用。以下几点除外。

1. 可以使用`char*`指针进行字节级别的访问。
2. unsigned 类型
3. const** 类型
4. 包含指定类型的结构体指针

定义为const的变量只能用const指针访问。以下几点除外：
1. 本来就不是const的变量，被转为const后可以去掉const。（const特性只能被添加不能被去除）
2. 具有mutable成员的const结构体。